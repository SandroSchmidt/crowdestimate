<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Personen mit Hindernis – Three.js</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    #sliderContainer {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 8px;
    }
    #settingsPanel {
      position: absolute;
      top: 50px;
      left: 10px;
      background: #eee;
      padding: 10px;
      border-radius: 5px;
      display: none;
    }
    .btn {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      padding: 6px 10px;
      background: #ccc;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>

<div id="sliderContainer">
  <label>Personenzahl: <input id="slider" type="range" min="0" max="250" value="0"></label>
</div>

<button id="toggleSettings" class="btn">⚙️</button>

<div id="settingsPanel">
  <label>Höhe Y: <input id="camHeight" type="range" min="1" max="50" step="1" value="10"></label><br>
  <label>Distanz: <input id="camDist" type="range" min="5" max="50" step="1" value="15"></label><br>
  <label>Auto-Rotate Speed: <input id="rotateSpeed" type="range" min="0" max="0.001" step="0.0001" value="0.0005"></label><br>
  <label>Licht mit Schatten:
    <select id="shadowToggle">
      <option value="true">An</option>
      <option value="false">Aus</option>
    </select>
  </label><br>
  <label>Obstacle:
    <select id="obstacleToggle">
      <option value="false">Aus</option>
      <option value="true">An</option>
    </select>
  </label>
</div>

<script>
let scene, camera, renderer, personGroup;
const boxSize = 10;
let lastCount = 0;
let autoRotate = true;
let rotateSpeed = 0.0005;
let camRadius = 15;
let camHeight = 10;
let light, shadowEnabled = false;
let obstacleEnabled = false;
let obstacleMesh = null;

const personModel = createPersonModel();

init();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(15, 10, 15);
  camera.lookAt(0, 0, 0);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(20, 30, 20);
  light.castShadow = false;
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x888888));

  const ground = new THREE.Mesh(
    new THREE.BoxGeometry(boxSize, 0.1, boxSize),
    new THREE.MeshStandardMaterial({ color: 0xcccccc })
  );
  ground.position.y = -0.05;
  scene.add(ground);

  personGroup = new THREE.Group();
  scene.add(personGroup);

  // UI-Events
  d3.select("#slider").on("input", function () {
    updatePeople(+this.value);
  });

  document.getElementById("camHeight").addEventListener("input", e => {
    camHeight = parseFloat(e.target.value);
  });
  document.getElementById("camDist").addEventListener("input", e => {
    camRadius = parseFloat(e.target.value);
  });
  document.getElementById("rotateSpeed").addEventListener("input", e => {
    rotateSpeed = parseFloat(e.target.value);
    autoRotate = rotateSpeed > 0;
  });
  document.getElementById("shadowToggle").addEventListener("change", e => {
    shadowEnabled = e.target.value === "true";
    light.castShadow = shadowEnabled;
  });
  document.getElementById("obstacleToggle").addEventListener("change", e => {
    obstacleEnabled = e.target.value === "true";
    updateObstacle();
    updatePeople(lastCount);
  });

  document.getElementById("toggleSettings").addEventListener("click", () => {
    const panel = document.getElementById("settingsPanel");
    panel.style.display = panel.style.display === "none" ? "block" : "none";
  });

  animate();
}

function updateObstacle() {
  if (obstacleMesh) {
    scene.remove(obstacleMesh);
    obstacleMesh = null;
  }

  if (obstacleEnabled) {
    const size = 3;
    const box = new THREE.Mesh(
      new THREE.BoxGeometry(size, 3, size),
      new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    box.position.set(0, 0.5, 0);
    scene.add(box);
    obstacleMesh = box;
  }
}

function createPersonModel() {
  const group = new THREE.Group();

  const body = new THREE.Mesh(
    new THREE.CylinderGeometry(0.2, 0.25, 0.8, 12),
    new THREE.MeshStandardMaterial({ color: 0x3366cc })
  );
  body.position.y = 1;
  group.add(body);

  const head = new THREE.Mesh(
    new THREE.SphereGeometry(0.20, 12, 12),
    new THREE.MeshStandardMaterial({ color: 0xdb9c37 })
  );
  head.position.y = 1.6;
  group.add(head);

  const armMaterial = new THREE.MeshStandardMaterial({ color: 0x3366cc });
  const armLeft = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.6, 8), armMaterial);
  armLeft.position.set(-0.25, 1.1, 0);
  armLeft.rotation.z = Math.PI;
  group.add(armLeft);

  const armRight = armLeft.clone();
  armRight.position.x = 0.25;
  group.add(armRight);

  const legMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const legLeft = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8), legMaterial);
  legLeft.position.set(-0.15, 0.4, 0);
  group.add(legLeft);

  const legRight = legLeft.clone();
  legRight.position.x = 0.15;
  group.add(legRight);

  return group;
}

function updatePeople(count) {
  const delta = count - lastCount;
  if (delta > 0) {
    for (let i = 0; i < delta; i++) {
      personGroup.add(createSinglePerson());
    }
  } else if (delta < 0) {
    for (let i = 0; i < -delta; i++) {
      personGroup.remove(personGroup.children[personGroup.children.length - 1]);
    }
  }
  lastCount = count;
}

function createSinglePerson() {
  const minDistance = 0.5;
  let px, pz;
  let placed = false;
  let attempts = 0;
  const positions = personGroup.children.map(p => ({ x: p.position.x, z: p.position.z }));

  while (!placed && attempts < 100) {
    px = (Math.random() - 0.5) * boxSize;
    pz = (Math.random() - 0.5) * boxSize;

    const tooClose = positions.some(pos => {
      const dx = pos.x - px;
      const dz = pos.z - pz;
      return Math.sqrt(dx * dx + dz * dz) < minDistance;
    });

    let insideObstacle = false;
    if (obstacleEnabled) {
      insideObstacle = Math.abs(px) < 2 && Math.abs(pz) < 2; // Block ist 2x2m in der Mitte
    }

    if (!tooClose && !insideObstacle) placed = true;
    attempts++;
  }

  const person = personModel.clone();
  person.position.set(px, 0, pz);
  person.rotation.y = Math.random() * Math.PI * 2;

  if (!placed) {
    const head = person.children.find(c => c.geometry.type === "SphereGeometry");
    if (head) head.material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
  }

  const bodyColor = new THREE.Color(Math.random() * 0xffffff);
  const body = person.children.find(c => c.geometry.type === "CylinderGeometry" && c.position.y > 0.5);
  if (body) body.material = new THREE.MeshStandardMaterial({ color: bodyColor });

  person.children.forEach(c => {
    if (c.geometry.type === "CylinderGeometry" && Math.abs(c.position.y - 1.1) < 0.05) {
      c.material = new THREE.MeshStandardMaterial({ color: bodyColor });
    }
  });

  return person;
}

function animate() {
  requestAnimationFrame(animate);
  if (autoRotate) {
    const time = Date.now() * rotateSpeed;
    camera.position.x = camRadius * Math.cos(time);
    camera.position.z = camRadius * Math.sin(time);
  }
  camera.position.y = camHeight;
  camera.lookAt(0, 0, 0);
  renderer.render(scene, camera);
}

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
